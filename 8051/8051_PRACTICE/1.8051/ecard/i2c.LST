C51 COMPILER V9.02   I2C                                                                   12/02/2023 18:12:58 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN i2c.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE i2c.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg51.h>
   2          #include "types.h"
   3          #include "delay.h"
   4          #include "i2c_defines.h"
   5          
   6          // low level embedded-c driver for i2c bus events
   7          
   8          /* routine to issue start event/condition */
   9          void i2cStart(void)
  10          {
  11   1      //  sda=1;//default status of sda line can be avoided
  12   1      //  scl=1;//default status of scl line can be avoided
  13   1        sda=0;//pull down sda from high to low issues start event 
  14   1      }
  15          
  16          /* routine to issue re start event/condition in-between  certain i2c
  17             communication alogirthm somewhere between the start & stop.
  18          */
  19          void i2cReStart(void)
  20          {
  21   1        scl=0;//make scl low to make/release sda 1
  22   1        sda=1;//default status of sda line can be avoided
  23   1        scl=1;//default status of scl line can be avoided
  24   1        sda=0;//pull down sda from high to low issues start event 
  25   1      }
  26          
  27          /* routine to issue stop event/condition */
  28          void i2cStop(void)
  29          {
  30   1        scl=0;//to change status of sda ,scl is made low during communication
  31   1        sda=0;//now scl is made low
  32   1        scl=1;//scl line is released
  33   1        sda=1;//sda is raised from low to high to issue stop condition
  34   1      }
  35          
  36          
  37          
  38          /* 
  39            routine for serializing out byte in order msb toward lsb across sda line
  40            with clock cycles across scl line
  41          */
  42          void i2cWrite(u8 byte)
  43          {
  44   1        u8 i;
  45   1        for(i=0;i<8;i++)
  46   1        {
  47   2          scl=0;//to allow change of bit status across sda line
  48   2          sda=(byte>>(7-i))&1;//serialize-out data msb to lsb/changing sda line
  49   2          //sda= (byte&(0x80>>i)) ? 1 : 0;//serialize data msb to lsb/changing sda line
  50   2          /*if(byte & (0x80>>i))
  51   2            sda=1;
  52   2          else
  53   2            sda=0;
  54   2          */
  55   2          scl=1;//release scl line so that slave can check/read/monitor bit received
C51 COMPILER V9.02   I2C                                                                   12/02/2023 18:12:58 PAGE 2   

  56   2                //across
  57   2        }  
  58   1      }
  59          
  60          /* 
  61            routine for serializing-in a byte in order msb toward lsb across sda line
  62            with clock cycles across scl line
  63          */
  64          u8 i2cRead(void)
  65          {
  66   1        u8 i,buff;
  67   1        for(i=0;i<8;i++)
  68   1        {
  69   2          scl=0;//to allow change of bit status across sda line by slave
  70   2          scl=1;//master releases scl line so that it can check/read/monitor bit received
  71   2                //across sda line
  72   2          if(sda)//reading valid bit status
  73   2            buff|=0x80>>i; //& updating appropriate bit pos with '1' level
  74   2          else
  75   2            buff&=~(0x80>>i);//or updating appropriate bit pos with '0' level
  76   2        }
  77   1        return buff;   
  78   1      }
  79          
  80          
  81          
  82          
  83          
  84          /*
  85             master taking acknowlegement from slave after writing byte of information
  86          */
  87          
  88          void i2cSlaveAck(void)
  89          {
  90   1        scl=0;//master make scl=0 to change sda to high/release sda
  91   1        sda=1;//master is releasing sda,so that slave can pull down sda for +ack
  92   1        scl=1;//master releases scl also
  93   1        while(sda);//master is checking sda if it is high/low,
  94   1                   //if sda continues to remain high,implies -ve ack/no ack received
  95   1                   //sda is low ,implies +ve ack,& master can continue further activity. 
  96   1      }
  97          
  98          /*
  99             master issues not of acknowlegement onto bus for slave for only byte/last of several
 100             bytes read from slave
 101          */
 102          
 103          void i2cNAck(void)
 104          {
 105   1        scl=0;//master make scl=0 to change sda to high/release sda
 106   1        sda=1;//master is releasing sda,so slave can read this status of not of acknowledge
 107   1        scl=1;//master releases scl,slave read here that status 
 108   1      }
 109          
 110          /* 
 111             master issue acknowlegment to slave for every byte read except the last
 112             of several bytes being read.
 113          */
 114          
 115          void i2cMasterAck(void)
 116          {
 117   1         scl=0;//master makes scl=0 to pull down sda =0 for issuing its +ve ack
C51 COMPILER V9.02   I2C                                                                   12/02/2023 18:12:58 PAGE 3   

 118   1         sda=0;//master pulls down sda for +ve ack issue,& slave release sda from its end
 119   1         scl=1;//master release scl ,so that slave can read that status of ack (+ve/-ve)
 120   1         scl=0;//master now has to release sda,so scl=0
 121   1         sda=1;//now master release sda from low to high      
 122   1      }
 123          
 124          
 125          
 126          
 127          
 128          
 129          
 130          // low lever embedded-c drivers for i2c communication algorithms
 131          
 132          /*
 133             This routine is attempts to write to any random location of the eeprom
 134             by each time providing the address location where data needs to be written into
 135          */
 136          void i2cDevByteWrite(u8 slaveAddr7Bit,u8 wBuffAddr,u8 dat)
 137          {
 138   1        i2cStart();
 139   1        i2cWrite((slaveAddr7Bit)|0);
 140   1        i2cSlaveAck();
 141   1        i2cWrite(wBuffAddr);
 142   1        i2cSlaveAck();
 143   1        i2cWrite(dat);
 144   1        i2cSlaveAck();
 145   1        i2cStop();
 146   1        delay_ms(10);
 147   1      }
 148          
 149          /*
 150             This routine is attempts to read from any random location of the eeprom
 151             by each time providing the address location where data needs to read from
 152          */
 153          u8 i2cDevRandomRead(u8 slaveAddr7Bit,u8 rBuffAddr)
 154          {
 155   1        u8 buff;
 156   1        i2cStart();
 157   1        i2cWrite((slaveAddr7Bit)|0);
 158   1        i2cSlaveAck();
 159   1        i2cWrite(rBuffAddr);
 160   1        i2cSlaveAck();
 161   1        i2cReStart();
 162   1        i2cWrite((slaveAddr7Bit)|1);
 163   1        i2cSlaveAck();
 164   1        buff=i2cRead();
 165   1        i2cNAck();
 166   1        i2cStop(); 
 167   1      
 168   1        return buff;
 169   1      }
 170          
 171          
 172          
 173          
 174          
 175          
 176          void i2cDevPageWrite(u8 slaveAddr7Bit,
 177                               u8 wBuffSeqStartAddr,
 178                               u8 *ptr8Bytes,
 179                               u8 nBytes)
C51 COMPILER V9.02   I2C                                                                   12/02/2023 18:12:58 PAGE 4   

 180          {
 181   1        u8 i;
 182   1        i2cStart();
 183   1        i2cWrite((slaveAddr7Bit)|0);
 184   1        i2cSlaveAck();
 185   1        i2cWrite(wBuffSeqStartAddr);
 186   1        i2cSlaveAck();
 187   1      
 188   1        for(i=0;i<nBytes;i++)
 189   1        {
 190   2          i2cWrite(*ptr8Bytes++);
 191   2          i2cSlaveAck();
 192   2        }
 193   1        i2cStop();
 194   1        delay_ms(10);
 195   1      }
 196          
 197          void i2cDevSeqRead(u8 slaveAddr7Bit,
 198                               u8 rBuffSeqStartAddr,
 199                               u8 *ptr8Bytes,
 200                               u8 nBytes)
 201          {
 202   1        u8 i;
 203   1        i2cStart();
 204   1        i2cWrite((slaveAddr7Bit)|0);
 205   1        i2cSlaveAck();
 206   1        i2cWrite(rBuffSeqStartAddr);
 207   1        i2cSlaveAck();
 208   1        i2cReStart();
 209   1        i2cWrite((slaveAddr7Bit)|1);
 210   1        i2cSlaveAck();
 211   1        for(i=0;i<nBytes-1;i++)
 212   1        {
 213   2          ptr8Bytes[i]=i2cRead();
 214   2          i2cMasterAck();
 215   2        }
 216   1        ptr8Bytes[i++]=i2cRead();
 217   1        ptr8Bytes[i]='\0';
 218   1        i2cNAck();
 219   1        i2cStop();
 220   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
