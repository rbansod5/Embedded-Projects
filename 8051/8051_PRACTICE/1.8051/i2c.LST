C51 COMPILER V9.02   I2C                                                                   12/01/2023 17:24:29 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN i2c.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE i2c.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h>
   2          #include "types.h"
   3          #include "delay.h"
   4          #include "i2c_defines.h"
   5          #include "i2c.h"
   6          
   7          // low level embedded-c driver for i2c bus events
   8          
   9          /* routine to issue start event/condition */
  10          void i2cStart(void)
  11          {
  12   1      //  sda=1;//default status of sda line can be avoided
  13   1      //  scl=1;//default status of scl line can be avoided
  14   1        sda=0;//pull down sda from high to low issues start event 
  15   1      }
  16          
  17          /* routine to issue re start event/condition in-between  certain i2c
  18             communication alogirthm somewhere between the start & stop.
  19          */
  20          void i2cReStart(void)
  21          {
  22   1        scl=0;//make scl low to make/release sda 1
  23   1        sda=1;//default status of sda line can be avoided
  24   1        scl=1;//default status of scl line can be avoided
  25   1        sda=0;//pull down sda from high to low issues start event 
  26   1      }
  27          
  28          /* routine to issue stop event/condition */
  29          void i2cStop(void)
  30          {
  31   1        scl=0;//to change status of sda ,scl is made low during communication
  32   1        sda=0;//now scl is made low
  33   1        scl=1;//scl line is released
  34   1        sda=1;//sda is raised from low to high to issue stop condition
  35   1      }
  36          
  37          
  38          
  39          /* 
  40            routine for serializing out byte in order msb toward lsb across sda line
  41            with clock cycles across scl line
  42          */
  43          void i2cWrite(u8 byte)
  44          {
  45   1        u8 i;
  46   1        for(i=0;i<8;i++)
  47   1        {
  48   2          scl=0;//to allow change of bit status across sda line
  49   2          sda=(byte>>(7-i))&1;//serialize-out data msb to lsb/changing sda line
  50   2          //sda= (byte&(0x80>>i)) ? 1 : 0;//serialize data msb to lsb/changing sda line
  51   2          /*if(byte & (0x80>>i))
  52   2            sda=1;
  53   2          else
  54   2            sda=0;
  55   2          */
C51 COMPILER V9.02   I2C                                                                   12/01/2023 17:24:29 PAGE 2   

  56   2          scl=1;//release scl line so that slave can check/read/monitor bit received
  57   2                //across
  58   2        }  
  59   1      }
  60          
  61          /* 
  62            routine for serializing-in a byte in order msb toward lsb across sda line
  63            with clock cycles across scl line
  64          */
  65          u8 i2cRead(void)
  66          {
  67   1        u8 i,buff;
  68   1        for(i=0;i<8;i++)
  69   1        {
  70   2          scl=0;//to allow change of bit status across sda line by slave
  71   2          scl=1;//master releases scl line so that it can check/read/monitor bit received
  72   2                //across sda line
  73   2          if(sda)//reading valid bit status
  74   2            buff|=0x80>>i; //& updating appropriate bit pos with '1' level
  75   2          else
  76   2            buff&=~(0x80>>i);//or updating appropriate bit pos with '0' level
  77   2        }
  78   1        return buff;   
  79   1      }
  80          
  81          
  82          
  83          
  84          
  85          /*
  86             master taking acknowlegement from slave after writing byte of information
  87          */
  88          
  89          void i2cSlaveAck(void)
  90          {
  91   1        scl=0;//master make scl=0 to change sda to high/release sda
  92   1        sda=1;//master is releasing sda,so that slave can pull down sda for +ack
  93   1        scl=1;//master releases scl also
  94   1        while(sda);//master is checking sda if it is high/low,
  95   1                   //if sda continues to remain high,implies -ve ack/no ack received
  96   1                   //sda is low ,implies +ve ack,& master can continue further activity. 
  97   1      }
  98          
  99          /*
 100             master issues not of acknowlegement onto bus for slave for only byte/last of several
 101             bytes read from slave
 102          */
 103          
 104          void i2cNAck(void)
 105          {
 106   1        scl=0;//master make scl=0 to change sda to high/release sda
 107   1        sda=1;//master is releasing sda,so slave can read this status of not of acknowledge
 108   1        scl=1;//master releases scl,slave read here that status 
 109   1      }
 110          
 111          /* 
 112             master issue acknowlegment to slave for every byte read except the last
 113             of several bytes being read.
 114          */
 115          
 116          void i2cMasterAck(void)
 117          {
C51 COMPILER V9.02   I2C                                                                   12/01/2023 17:24:29 PAGE 3   

 118   1         scl=0;//master makes scl=0 to pull down sda =0 for issuing its +ve ack
 119   1         sda=0;//master pulls down sda for +ve ack issue,& slave release sda from its end
 120   1         scl=1;//master release scl ,so that slave can read that status of ack (+ve/-ve)
 121   1         scl=0;//master now has to release sda,so scl=0
 122   1         sda=1;//now master release sda from low to high      
 123   1      }
 124          
 125          
 126          
 127          
 128          
 129          
 130          
 131          // low lever embedded-c drivers for i2c communication algorithms
 132          
 133          /*
 134             This routine is attempts to write to any random location of the eeprom
 135             by each time providing the address location where data needs to be written into
 136          */
 137          void i2cDevByteWrite(u8 slaveAddr7Bit,u8 wBuffAddr,u8 dat)
 138          {
 139   1        i2cStart();
 140   1        i2cWrite((slaveAddr7Bit)|0);
 141   1        i2cSlaveAck();
 142   1        i2cWrite(wBuffAddr);
 143   1        i2cSlaveAck();
 144   1        i2cWrite(dat);
 145   1        i2cSlaveAck();
 146   1        i2cStop();
 147   1        delay_ms(10);
 148   1      }
 149          
 150          /*
 151             This routine is attempts to read from any random location of the eeprom
 152             by each time providing the address location where data needs to read from
 153          */
 154          u8 i2cDevRandomRead(u8 slaveAddr7Bit,u8 rBuffAddr)
 155          {
 156   1        u8 buff;
 157   1        i2cStart();
 158   1        i2cWrite((slaveAddr7Bit)|0);
 159   1        i2cSlaveAck();
 160   1        i2cWrite(rBuffAddr);
 161   1        i2cSlaveAck();
 162   1        i2cReStart();
 163   1        i2cWrite((slaveAddr7Bit)|1);
 164   1        i2cSlaveAck();
 165   1        buff=i2cRead();
 166   1        i2cNAck();
 167   1        i2cStop(); 
 168   1      
 169   1        return buff;
 170   1      }
 171          
 172          
 173          
 174          
 175          
 176          
 177          void i2cDevPageWrite(u8 slaveAddr7Bit,
 178                               u8 wBuffSeqStartAddr,
 179                               u8 *ptr8Bytes,
C51 COMPILER V9.02   I2C                                                                   12/01/2023 17:24:29 PAGE 4   

 180                               u8 nBytes)
 181          {
 182   1        u8 i;
 183   1        i2cStart();
 184   1        i2cWrite((slaveAddr7Bit)|0);
 185   1        i2cSlaveAck();
 186   1        i2cWrite(wBuffSeqStartAddr);
 187   1        i2cSlaveAck();
 188   1      
 189   1        for(i=0;i<nBytes;i++)
 190   1        {
 191   2          i2cWrite(*ptr8Bytes++);
 192   2          i2cSlaveAck();
 193   2        }
 194   1        i2cStop();
 195   1        delay_ms(10);
 196   1      }
 197          
 198          void i2cDevSeqRead(u8 slaveAddr7Bit,
 199                               u8 rBuffSeqStartAddr,
 200                               u8 *ptr8Bytes,
 201                               u8 nBytes)
 202          {
 203   1        u8 i;
 204   1        i2cStart();
 205   1        i2cWrite((slaveAddr7Bit)|0);
 206   1        i2cSlaveAck();
 207   1        i2cWrite(rBuffSeqStartAddr);
 208   1        i2cSlaveAck();
 209   1        i2cReStart();
 210   1        i2cWrite((slaveAddr7Bit)|1);
 211   1        i2cSlaveAck();
 212   1        for(i=0;i<nBytes-1;i++)
 213   1        {
 214   2          ptr8Bytes[i]=i2cRead();
 215   2          i2cMasterAck();
 216   2        }
 217   1        ptr8Bytes[i++]=i2cRead();
 218   1        ptr8Bytes[i]='\0';
 219   1        i2cNAck();
 220   1        i2cStop();
 221   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
